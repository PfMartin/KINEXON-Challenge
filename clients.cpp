// main.cpp: Martin Pfatrisch
// Description: The program sends sensor locations generated by the location generator

#include <iostream>
#include <time.h>
#include <zmq.hpp>

#include "location_generator.h"
#include "position.pb.h"


// Prototypes for used functions
struct Location init_loc(void);
struct Location update_loc(struct Location);
position::GeneratedPosition update_position(position::GeneratedPosition gen_pos, uint64_t sensor_id, struct Location loc);
zmq::message_t serialize_message(position::GeneratedPosition gen_pos);

const int period = 1000;
static zmq::context_t ctx;

int main(void) {
  // Zmq socket setup
  zmq::socket_t sock(ctx, zmq::socket_type::push);
  sock.bind("tcp://127.0.0.1:5555");
  std::cout << "Binding socket to tcp://127.0.0.1:5555" << std::endl;

  // Array of locations
  struct Location locs[10];

  position::GeneratedPosition gen_pos;

  zmq::message_t z_out;

  // Initialize locations
  for(int i = 0; i < 10; i++) {
    locs[i] = init_loc();

    // Initialize a new position
    gen_pos = update_position(gen_pos, i, locs[i]);
    z_out = serialize_message(gen_pos);
    sock.send(z_out, zmq::send_flags::none);
  }

  std::this_thread::sleep_for(std::chrono::milliseconds(period));


  while(1) {
    for(int i = 0; i < 10; i++) {
      locs[i] = update_loc(locs[i]);

      // Update the position
      gen_pos = update_position(gen_pos, i, locs[i]);

      z_out = serialize_message(gen_pos);
      sock.send(z_out, zmq::send_flags::none);
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(period));
  }

  return 0;
}


/**
 * update_position: Updates a GeneratedPosition with a sensor id, a time stamp and values from a location
 * @param  [position::GeneratedPosition]          gen_pos   GeneratedPosition, that should be updated
 * @param  [uint64_t]                             sensor_id Identifiert of the sensor
 * @param  [uint64_t]                             t_stamp   Time stamp in seconds
 * @param  [struct Location]                      loc       Location, which should its x, y and z coordinates to the GeneratedPosition
 * @return [position::GeneratedPosition]                    The updated GeneratedPosition
 */
position::GeneratedPosition update_position(position::GeneratedPosition gen_pos, uint64_t sensor_id, struct Location loc) {
  uint64_t t_stamp;
  t_stamp = time(NULL);

  gen_pos.set_sensorid(sensor_id);
  gen_pos.set_timestamp_usec(t_stamp);
  gen_pos.mutable_position()->set_x(loc.x);
  gen_pos.mutable_position()->set_y(loc.y);
  gen_pos.mutable_position()->set_z(loc.z);

  return gen_pos;
}


/**
 * serialize_message: Serializes a zmq message in order to send it
 * @param   [position::GeneratedPosition]   gen_pos   The GeneratedPosition, that should be serialized
 * @return  [zmq::message_t]                          The serialized message ready to be send
 */
zmq::message_t serialize_message(position::GeneratedPosition gen_pos) {

  auto bytes = gen_pos.ByteSizeLong();
  zmq::message_t z_out(bytes);
  gen_pos.SerializeToArray(z_out.data(), bytes);

  std::cout << "\nSensor " << gen_pos.sensorid() << " initialized: " << gen_pos.IsInitialized() << std::endl;
  std::cout << "Sending Sensor " << gen_pos.sensorid() << std::endl;

  return z_out;
}
